###"笨办法"学python练习题

**ex4.py**

+ **变量（ variable）**用来指代某个东西的名字。 

**ex5.py** 

1. print"round()"如何实现print中的函数调用。
2. 可以编制文本菜单将单位提前选择，当然需要if then 语句。
3. ？格式化字符串=字符串+%+tuple(数组)
4. **格式化字符（format string）**

__ex8.py__

*  p29页:_有`%r`python会用最有效的方式打印出字符串，而不是完全按照你写的方式打印。_(__那么我如何知道自己输出是什么样的？__)
*  `%r`是用来调试的，我想知道怎么用？r被称作**“原始表示”（raw representation）**


**ex9.py**
 
+ **总结：**print 后有`,`则不换行，继续显示。print 中有`\n`则新行 
+ **"""的作用，可以直接给格式，想换行随意，不用转义符，其实增加了代码的可读性**

**ex10.py**

+ p34页的代码需要**重新看下。** 
+ **转义字符（escape sequences）** 

**ex11.py**

+ 引入**raw_input()**函数
+ input() 本质上还是使用 raw_input() 来实现的，只是调用完 raw_input() 之后再调用 eval() 函数，所以，你甚至可以将表达式作为 input() 的参数，并且它会计算表达式的值并返回它。
不过在 Built-in Functions 里有一句话是这样写的：Consider using the raw_input() function for general input from users.
除非对 input() 有特别需要，否则一般情况下我们都是推荐使用 raw_input() 来与用户交互。

**ex12.py**

+  语句python -m是python以脚本方式运行模块。
+  **pydoc**是文档生成工具。 [pydoc用法](http://www.jb51.net/article/67119.htm)
例如	`D:\>python -m pydoc -p 1234 #比如说: 端口为1234`
	`pydoc server ready at http://localhost:1234/`
	`pydoc server stopped`
pydoc 是把 help 的内容转成 HTML 输出。
两者内容都来自 python 模块中的 docstring

**ex13.py**

+ **import语句：** 可以将python的**模块（module）**(某种特性)引入脚本。
+ **参数变量（argument variable）:**这个变量保存着你运行python脚本时传递给python脚本的参数。（执行命令就应该输入的。）
+ **解包（unpack）:**将所有的参数依次赋值给左边的变量。
+ **Python模块是什么？：**一个完整大型的python程序是由模块和包的形式组织起来的，可见模块在python中的重要性。模块是一种组织型式，它许多有关联（关系）的代码组织放到单独的独立文件中。简单的说，可以把模块理解为一个包含了许多强大功能（方法）的包。在python标准库中就包含许多模块，有很多模块内的方法都会被经常使用到。
+ **Python模块有什么作用？**

 + 模块内有许多函数方法，利用这些方法可以更简单的完成许多工作。
 + 模块可以在文件中永久保存代码。在python交互式解释器中操作输入的代码，在退出python时是不会被保存的，而模块文件中的代码是永久存在的。
 + 从实用性方面来说，模块可以跨系统平台使用，只需要Copy代码就可以。比如说，有一个全局对像，会被许多文件使用，这时为了方便把它写入一个模块中，再被调用是最好的方法。
 

**ex14.py**

+ p43我也不知道为什么python必须在命令行中运行，而不能在python环境中运行。
 
**ex15.py**
  
+ **“单下划线” 开始的成员变量叫做保护变量**，意思是只有类对象和子类对象自己能访问到这些变量；
+ **"双下划线"开始的是私有成员** ，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。
+ 在python解释器中运行open,read。需要这样做`txt = open(filename)`→`print txt.read()`
+ `txt = open(filename)`返回的是文件对象，而非文件内容，所以，想知道内容还需要	`txt.read()`,我觉得还应该及时的`txt.close()` 
+ **from sys import argv** sys是个软件包，这句话的意思是从软件包中取出argv这个特性来，供我使用。 

**ex16.py**

+ 会在**当前（powershell运行程序的目录）**目录下**生成（即使不存在参数文件也产生）**文件
+ 文件操作的命令**汇总**
  + close 关闭文件
  + read 读取文件
  + readline 读取文件中一行
  + truncate 清空文件
  + write(stuff) 将stuff写入文件
+ **为什么不设计个程序把所有前面编写的文件汇总起来？**

**ex17.py**

+  关于open 模式：
  + w     以写方式打开，
  + a     以追加模式打开 (从 EOF 开始, 必要时创建新文件)
  + r+     以读写模式打开
  + w+     以读写模式打开 (参见 w )
  + a+     以读写模式打开 (参见 a )
  + rb     以二进制读模式打开
  + wb     以二进制写模式打开 (参见 w )
  + ab     以二进制追加模式打开 (参见 a )
  + rb+    以二进制读写模式打开 (参见 r+ )
  + wb+    以二进制读写模式打开 (参见 w+ )
  + ab+    以二进制读写模式打开 (参见 a+ )
+ "w"（write）写入模式，"r"（read）表示读取，"a"（append）表示追加。
+ "+"修饰符，这样的话文件将以同时读写的方式打开。
+ **如果只写open（filename）那就使用"r"模式打开，这是open（）函数的默认工作方式。**
+ **常见的文件运算：** 
  + 操作                     解释
  + output=open('/tmp/python.data','w') 创建输出文件，写入文件
  + input=open('/tmp/python.data','r') 创建输入文件，读取文件
  + input=open('/tmp/python.data')   创建输入文件，读取文件 r是默认值
  + aString=input.read()         把整个文件读进一个字符串
  + aString=input.read(N)         读取前面的N个字节到一个字符串
  + aString=input.readline(N)      读取下一行到一个字符串
  + aList=input.readlines()         读取剩下的行到一个字符串列表
  + output.write(aString)         写入字节字符串到文件
  + output.writelines(aList)    把列表内所有字符串写入到文件,列表里不能有数字，数字需要转换为字符串
  + output.close()            手动关闭（当文件收集完成时会关闭文件
  + output.flush()            把输出缓冲区刷到硬盘中，但不关闭文件。
  + anyfile.seek(N)            修改文件位置到偏移量N处以便进行一下操作

+ **cat命令（concatenate）**

**ex18.py**
 
+ **使用#1和#2，它们可以让你创建“迷你脚本”或者“小命令”**

+ **函数定义**以def开始，函数名以字符和下划线组成数字不能出现在首位，函数名紧跟括号，可以不要参数，多个参数需要用“，”隔开，参数名不能重复，函数括号后有冒号，定义代码前有四个空格（1个Tab）,结束时取消缩进。
+ *args中的的星号是将所有参数都接受进来，然后放到args的列表中。

**ex19.py**

+ 有10种不同的方式运行函数（理论上有无穷多种方式运行一个函数，有趣！）
+ **什么是python内建函数：**python系统中自带的一些函数就叫做**内建函数**，比如：dir()、type()等等，不需要我们自己编写。还有一种是__第三方函数__，就是其它程序员编好的一些函数，共享给大家使用。前面说的这两种函数都是拿来就可以直接使用的。最后就是我们自己编些的方便自己工作学习用的函数，就叫做__自定义函数__了。

**ex20.py**  
 
+ file.seek()可以将文件游标移动到文件的任意位置,file.seek()方法标准格式是：seek(offset,whence=0),offset：开始偏移量，也就是代表需要移动偏移的字节数。 whence：给offset参数一个定义，表示要从哪个位置开始偏移；0代表从文件开头开始算起，1代表从当前位置开始算起，2代表从文件末尾算起。
+ **readline()会读取文件的每一个字节，直到找到\n为止；print打印时会添加一个\n**

**ex21.py**
 
+ return 语句就是将结果返回到调用的地方，并把程序控制权一起返回。
+ 谜题就是个**嵌套** 
 

**ex25.py**

+ **split()函数**：
+ Python中有split()和os.path.split()两个函数：
  + split()：拆分字符串。通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list）
  + os.path.split()：按照路径将文件名和路径分割开
+ 语法：str.split(str="",num=string.count(str))[n]
  + 参数说明：
  str：   表示为分隔符，默认为空格，但是不能为空('')。若字符串中没有分 隔符，则把整个字符串作为列表的一个元素
  num：表示分割次数。如果存在参数num，则仅分隔成 num+1 个子字符串，并且 每一个子字符串可以赋给新的变量
  [n]：   表示选取第n个分片
  注意：当使用空格作为分隔符时，对于中间为空的项会自动忽略

+ **pop()函数**：
  + 描述：pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。
  + 语法： list.pop(obj=list[-1])；obj -- 可选参数，要移除列表元素的对象。
     + 如果为空则默认为-1最后一项。
     + 第一个原始是0，下来1,2，3依次排序   
     
+ **sorted()函数（内建函数）** 对List、Dict进行排序
  +  >>> sorted([36, 5, 12, 9, 21])→[5, 9, 12, 21, 36]
  +  >>> sorted(['bob', 'about', 'Zoo', 'Credit'])→['Credit', 'Zoo', 'about', 'bob']
  
+ 把一段程序当做**模块**调用，那么**模块**中定义的函数就可以直接调用。（你没必要自己做轮子！）
  
+ **妙极：** 在使用**help(ex25)**命令时，函数的介绍里面即是当时的注释内容，也就是模块帮助文档的内容其实就是`"""`之间的内容。也叫__文档注释(documentation comment)__
+ 嫌输入ex25.麻烦，就用__`from ex25 import *`__的方式**导入模块**

**ex28.py**

+  遇到布尔运算，多使用短路逻辑。

**ex31.py**
  
+  P88 怎么判断一个数处于某个值域之中？ 两种办法①1<x<10,②x in range(1,10) (但是如果只是在命令行中用的话range表示1-9的9个整数)？
+  布尔表达式的结果如何打印？

**ex37.py**

+ try语法：
以下为简单的try....except...else的语法：
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生
try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。
如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。
如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。
如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。
实例

+ exec:exec语句用来执行储存在字符串或文件中的Python语句。例如，我们可以在运行时生成一个包含Python代码的字符串，然后使用exec语句执行这些语句
+ exec语句用来执行储存在字符串或文件中的Python语句。
eval语句用来计算存储在字符串中的有效Python表达式。
+ yield:包含了关键字"yield"的函数就不是普通的函数。当含有这个关键字的函数被调用的时候，这个函数在遇到yield的时候会停止运行，并且返回一个迭代器（iterator）。每次请求一个值，就会执行生成的代码。直到遇到一个yield或者return。
